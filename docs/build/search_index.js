var documenterSearchIndex = {"docs":
[{"location":"#EigenstratFormat","page":"EigenstratFormat","title":"EigenstratFormat","text":"","category":"section"},{"location":"#Contents","page":"EigenstratFormat","title":"Contents","text":"","category":"section"},{"location":"#Index","page":"EigenstratFormat","title":"Index","text":"","category":"section"},{"location":"#EigenstratFormat.EigenstratFormat","page":"EigenstratFormat","title":"EigenstratFormat.EigenstratFormat","text":"Methods for the Eigenstrat format that is commonly used in genetics.\n\n\n\n\n\n","category":"module"},{"location":"#EigenstratFormat._alleles-Tuple{Vector{UInt8}, Int64}","page":"EigenstratFormat","title":"EigenstratFormat._alleles","text":"_alleles(bytes::Vector{UInt8}, idx::Int64)\n\nReturn the number of variant alleles for a specified individual.\n\nbytes: Row of bytes that encode an SNP for all individuals.\n\nidx: Index of the individual.\n\n\n\n\n\n","category":"method"},{"location":"#EigenstratFormat._bitpair-Tuple{UInt8, Integer}","page":"EigenstratFormat","title":"EigenstratFormat._bitpair","text":"_bitpair(byte::UInt8, pos::Int64)\n\nExtract 2 bits from a byte. The bit positions start at 0. Allowed are values 0, 1, 2, 3.\n\n\n\n\n\n","category":"method"},{"location":"#EigenstratFormat._encode-Tuple{Tuple{Char, Char}, UInt8, Int64, Tuple{Char, Char}}","page":"EigenstratFormat","title":"EigenstratFormat._encode","text":"_encode(\n    genotype::Tuple{Char, Char},\n    byte::UInt8,\n    position::Int64,\n    reference_snp::Tuple{Char, Char}\n)\n\nEncode the given genotype in a byte at the given bitpair position (0..3).\n\nEach SNP is characterized by a Tuple of two alleles. The reference_snp contains the reference allele and the derived allele.\n\n\n\n\n\n","category":"method"},{"location":"#EigenstratFormat._hashit-Tuple{AbstractString}","page":"EigenstratFormat","title":"EigenstratFormat._hashit","text":"_hashit(sequence::String)\n\nCalculate the hashsum of a String.\n\nThis is basically the same method as in Nick Patterson's original C code.\n\nHowever, the original C version uses 32 bit integer values and integer overflows which may result in undefined behavior on some machines.  This method uses 64 bit integers to circumvent this problem.\n\nThis method will probably fail if the sequence contains non-ASCII Unicode characters. I do not know if this is defined in any way.\n\n\n\n\n\n","category":"method"},{"location":"#EigenstratFormat._hashsum-Tuple{Vector{<:AbstractString}}","page":"EigenstratFormat","title":"EigenstratFormat._hashsum","text":"_hashsum(sequences::Vector{<:AbstractString})\n\nCalculate the hashsum of a Vector of Strings using the _hashit() method.\n\nThis is the same method as the hasharr function in Nick Patterson's C code.\n\n\n\n\n\n","category":"method"},{"location":"#EigenstratFormat._hashsum-Tuple{Vector{<:AbstractString}}-2","page":"EigenstratFormat","title":"EigenstratFormat._hashsum","text":"_hashsum(sequences::Vector{<:AbstractString})\n\nCalculate the hashsum of a Vector of Strings using the _hashit() method.\n\nAgain this is basically the same method as in the software from David Reich's laboratory: https://github.com/DReichLab/EIG\n\n\n\n\n\n","category":"method"},{"location":"#EigenstratFormat.add_individual-NTuple{4, AbstractString}","page":"EigenstratFormat","title":"EigenstratFormat.add_individual","text":"add_individual(\n    inprefix::AbstractString,\n    outprefix::AbstractString,\n    ind_snp_file::AbstractString,\n    id::AbstractString;\n    gender = \"U\",\n    status = \"Control\"\n)\n\nAdd an individual to a database in Eigenstrat format. \n\nThe SNPs in the database remain untouched. If the individual displayes SNPs that are not listed in the database or multiallelic ones those SNPs are removed.\n\ninprefix: Prefix of the input database.\n\noutprefix: Prefix of the output database.\n\nind_snp_file: File containing SNP results for the individual. This should     work with files from Family Tree DNA Family Finder, MyHeritage, LivingDNA     and 23andMe.\n\nid: ID of the individual. For living persons I recommed the name.\n\ngender: U, F or M (Unknown, Female or Male)\n\nstatus: Control, Case or a population label.\n\n\n\n\n\n","category":"method"},{"location":"#EigenstratFormat.hash_ids-Tuple{AbstractString}","page":"EigenstratFormat","title":"EigenstratFormat.hash_ids","text":"hash_ids(filename::AbstractString)\n\nCreate the hashsum of .snp and .ind files. SNP and Individual files contain an ID in the first column. This method uses those IDs to calculate a hashsum. The sums are needed to store genotype data in packed format.\n\n\n\n\n\n","category":"method"},{"location":"#EigenstratFormat.read_eigenstrat_geno-Tuple{AbstractString, Int64, Int64}","page":"EigenstratFormat","title":"EigenstratFormat.read_eigenstrat_geno","text":"read_eigenstrat_geno(\n    genofile::AbstractString,\n    nsnp::Int64,\n    nind::Int64;\n    ind_idx::Vector{Int64} = [i for i = 1:nind]\n)\n\nRead a genofile in PackedAncestryMap format. The file must be unzipped.\n\ngenofile: filename\n\nnsnp: number of SNPs listed in .snp file.\n\nnind: number of individuals listed in .ind file.\n\nind_idx: Indices of individuals that should be read from the file.\n\nXXX Check for comment lines in .snp and .ind files.\n\nFile description: File header starts with GENO or TGENO (transposed GENO). So far files in the AADR archive seem to be GENO. So this method does not support the transposed TGENO format.\n\nThe text format contains one line per genotype:\n\nSNPID  SampleID   Numberofvariant_alleles\n\nThe packed format:\n\nEach SNP entry has 2 bits: 0, 1, 2, 3=missing, that denote the number of variant alleles as described at David Reich's laboratory.\n\n\n\n\n\n","category":"method"},{"location":"#EigenstratFormat.read_eigenstrat_ind-Tuple{AbstractString}","page":"EigenstratFormat","title":"EigenstratFormat.read_eigenstrat_ind","text":"read_eigenstrat_ind(indfile::AbstractString)\n\nRead individuals from Eigenstrat .ind file. The IND flle contains information about each individual in the database.\n\nReturn a DataFrame consisting of the columns:\n\nID, Gender, Status\n\nwhere\n\nGender: M (male), F (Female) or U (unknown).\n\nStatus: Case, Control or population label.\n\n\n\n\n\n","category":"method"},{"location":"#EigenstratFormat.read_eigenstrat_snp-Tuple{AbstractString}","page":"EigenstratFormat","title":"EigenstratFormat.read_eigenstrat_snp","text":"read_eigenstrat_snp(snpfile::AbstractString)\n\nRead Eigenstrat .snp file. The SNP file contains information about each SNP.\n\nReturn a DataFrame containing the columns:\n\nchromosome, rsid, cM, position, allele1, allele2\n\n\n\n\n\n","category":"method"},{"location":"#EigenstratFormat.read_snp_file-Tuple{AbstractString}","page":"EigenstratFormat","title":"EigenstratFormat.read_snp_file","text":"read_snp_file(filename::AbstractString)\n\nRead file with autosomal results from FTDNA Family Finder, My Heritage or LivingDNA. Should also work with 24andMe files but not tested.\n\nReturn a DataFrame containing the columns:\n\nrsid  chromosome  position  genotype\n\n\n\n\n\n","category":"method"},{"location":"#EigenstratFormat.write_23andMe-Tuple{AbstractString, Any}","page":"EigenstratFormat","title":"EigenstratFormat.write_23andMe","text":"write_23andMe(filename::AbstractString, snptable)\n\nWrite a table of SNPs in 23andMe file format.\n\nThis method is included to satisfy users who use Plink. Plink supports 23andMe files.\n\nThe snp table must satisfy the Tables.jl interface.\n\nThe table must contain the columns:\n\nrsid, chromosome, position, genotype\n\nHowever exact spelling is not mandatory.\n\n\n\n\n\n","category":"method"},{"location":"#EigenstratFormat.write_eigenstrat_geno-Tuple{AbstractString, Matrix{UInt8}}","page":"EigenstratFormat","title":"EigenstratFormat.write_eigenstrat_geno","text":"write_eigenstrat_geno(\n    genofile::AbstractString,\n    genomatrix::Matrix{UInt8};\n    ind_hash::Int64 = 0,\n    snp_hash::Int64 = 0\n)\n\nWrite a genotype matrix to file in PackedAncestryMap format.\n\nind_hash: Hashsum of .ind file.\n\nsnp_hash: Hashsum of .snp file.\n\n\n\n\n\n","category":"method"},{"location":"#EigenstratFormat.write_eigenstrat_ind-Tuple{AbstractString, DataFrames.AbstractDataFrame}","page":"EigenstratFormat","title":"EigenstratFormat.write_eigenstrat_ind","text":"write_eigenstrat_ind(filename::AbstractString, inds::AbstractDataFrame)\n\nWrite information about each individual to an .ind file.\n\nThe parameter inds contains information about each individual.\n\nThe DataFrame must have the columns\n\nID, Gender, Status\n\n\n\n\n\n","category":"method"},{"location":"#EigenstratFormat.write_eigenstrat_snp-Tuple{AbstractString, DataFrames.AbstractDataFrame}","page":"EigenstratFormat","title":"EigenstratFormat.write_eigenstrat_snp","text":"write_eigenstrat_snp(filename::AbstractString, snps::DataFrame)\n\nWrite .snp file in Eigenstrat format. The SNP file contains information about each SNP. The SNPs are provided as a DataFrame in parameter snps.\n\nThe DataFrame must consist of the following columns:\n\nchromosome, rsid, cM, position, allele1, allele2\n\n\n\n\n\n","category":"method"}]
}
